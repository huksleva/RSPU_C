# Структуры. Объединения. Перечисления. Лабораторная работа № 3. Задачи.

## Комплект 1. Структуры.
## Задание 1.1

### Постановка задачи
Создать некоторую структуру с указателем на некоторую функцию
в качестве поля. Вызвать эту функцию через имя переменной этой
структуры и поле указателя на функцию.

### Список идентификаторов
| Имя переменной | Тип переменной | Описание                  |
|----------------|----------------|---------------------------|
| s              | MyStruct       | Переменная типа MyStruct  |
| func           | \*void         | Указатель на функцию      |

### Код программы
```c
#include <stdio.h>

struct MyStruct{
    int (*func)(int, int);
} s;

int add(int a, int b) {
    return a + b;
}

int main() {
    s.func = &add;
    printf("%d\n", s.func(1, 2));

    return 0;
}
```
### Результат работы программы
![img.png](img.png)





## Задание 1.2

### Постановка задачи
Создать структуру для вектора в 3-х мерном пространстве. Реализовать и использовать в своей программе следующие операции над
векторами:
1. Скалярное умножение векторов;
2. Векторное произведение;
3. Модуль вектора;
4. Распечатка вектора в консоли.

### Математическая модель
![img1.png](img1.png)

### Список идентификаторов
| Имя переменной | Тип переменной | Описание                  |
|----------------|----------------|---------------------------|
| s              | MyStruct       | Переменная типа MyStruct  |
| func           | \*void         | Указатель на функцию      |
### Код программы
```c
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

typedef struct Vec{
    int x;
    int y;
    int z;
    char* name;
} Vector;

int scalarVectorMultiplication(Vector vec1, Vector vec2){
    return ((vec1.x * vec2.x) + (vec1.y * vec2.y) + (vec1.z * vec2.z));
}

Vector* VectorMultiplication(Vector vec1, Vector vec2){
    //после завершения работы функции переменная result удалится из оперативки
    Vector* result = (Vector*) malloc(sizeof(Vector));
    result->x = (vec1.y* vec2.z) - (vec1.z * vec2.y);
    result->y = -((vec1.x * vec2.z) + (vec1.z * vec2.x));
    result->x = (vec1.x * vec2.y) + (vec1.y * vec2.x);
    return result; //перед удалением result будет возвращен указатель
}

double ModuleVector(Vector vec1){
    return sqrt((vec1.x * vec1.x) + (vec1.y * vec1.y) + (vec1.z * vec1.z));
}

void PrintVector(Vector vec1){
    printf("Vector %s: %d %d %d\n", vec1.name, vec1.x, vec1.y, vec1.z);
}

int main() {
    Vector v = {1,2,3, "MyName"};
    PrintVector(v);
    printf("ModuleVector: %f\n", ModuleVector(v));
    printf("ScalarVectorMultiplication: %d\n", scalarVectorMultiplication(v, v));

    Vector *result = VectorMultiplication(v, v);
    printf("VectorMultiplication: %d %d %d\n", result->x, result->y, result->z);
    free(result);

    return 0;
}
```
### Результат работы программы
