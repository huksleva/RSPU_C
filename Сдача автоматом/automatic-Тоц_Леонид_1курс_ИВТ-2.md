# Программирование - Язык C. Сдача автоматом

## Задание №1. Проверка сбалансированности скобок в выражении

### Постановка задачи
**Напишите программу для проверки корректности расстановки круглых, фигурных и квадратных скобок в заданной строке.**
- **Вход.** Строка с выражением, содержащим скобки (может включать и другие символы).
- **Выход.** Вывести YES, если все типы скобок в строке корректно сбалансированы, или NO – если допущена
ошибка в порядке скобок.
- **Требования.** Для проверки использовать стек. Алгоритм должен учитывать соответствие типов скобок
(например, \[ соответствует \]) и их порядок вложенности. Программа игнорирует несвязанные символы и
анализирует только скобки. При обнаружении несбалансированной скобочной структуры обработать ситуацию и вывести NO. Использование стека должно быть реализовано вручную (например, через массив
или связный список), без использования сторонних коллекций.

### Список идентификаторов
| Имя переменной  | Тип переменной | Описание                     |
|-----------------|----------------|------------------------------|
| stack           | Stack*         | указатель на стек            |
| round_brackets  | целое число    | количество круглых скобок    |
| figure_brackets | целое число    | количество фигурных скобок   |
| square_brackets | целое число    | количество квадратных скобок |
| ch              | char           | символ                       |


### Код программы
```c
#include <stdio.h>
#include <malloc.h>

typedef struct StackElement {
    struct StackElement *prev;
    char data;
} StackElement;

typedef struct Stack {
    StackElement *head;
} Stack;

void StackInit(Stack *stack) {
    stack->head = NULL;
}

// Добавление элемента в стек
void push(Stack *stack, const char data) {
    StackElement *element = (StackElement *) malloc(sizeof(StackElement));
    element->data = data;
    element->prev = stack->head;
    stack->head = element;
}

// Извлечения элемента из стека
char pop(Stack *stack) {
    if (stack->head == NULL) {
        printf("Stack is empty.\n");
        return 0; // В ASCII 0 обозначает NULL
    }
    const char data = stack->head->data;
    StackElement *st = stack->head;
    stack->head = stack->head->prev;
    free(st);
    return data;
}

int main() {
    printf("Enter the string with round, square and figure brackets:");
    Stack stack;
    StackInit(&stack);
    push(&stack, (char) getchar());

    while (stack.head->data != '\n') {
        push(&stack, (char) getchar());
    }

    int round_brackets = 0, figure_brackets = 0, square_brackets = 0;
    char ch = pop(&stack); // Здесь ch всегда = '/n' (символ переноса строки, он же Enter)

    while ((stack.head != NULL) && (ch != 0)) {
        ch = pop(&stack);

        // Проверка на круглые скобки
        if (ch == '(') {
            round_brackets++;
        } else if (ch == ')') {
            round_brackets--;
        }

        // Проверка на фигурные скобки
        if (ch == '{') {
            figure_brackets++;
        } else if (ch == '}') {
            figure_brackets--;
        }

        // Проверка на квадратные скобки
        if (ch == '[') {
            square_brackets++;
        } else if (ch == ']') {
            square_brackets--;
        }
    }

    if ((round_brackets == 0) && (figure_brackets == 0) && (square_brackets == 0)) {
        printf("YES\n");
    } else {
        printf("NO\n");
    }

    return 0;
}
```
## Результат работы программы
![img.png](img.png)

## Задание №3. Генерация треугольника Паскаля

### Постановка задачи
Напишите программу, которая выводит первые N строк треугольника Паскаля.
- **Вход.** Целое число N – количество требуемых строк треугольника Паскаля.
- **Выход.** N строк, каждая из которых содержит соответствующие коэффициенты треугольника Паскаля, разделённые пробелами.
- **Требования.** Для хранения каждой строки треугольника динамически выделять массив соответствующего
размера. Не использовать фиксированные размерности массивов, расчёт должен работать для любого N
разумного размера. После генерации всех строк освободить всю выделенную память (не допускать утечки
памяти).

### Математическая модель
![img_1.png](img_1.png)

### Список идентификаторов
| Имя переменной | Тип переменной       | Описание                      |
|----------------|----------------------|-------------------------------|
| N              | unsigned short       | количество строк треугольника |
| i              | unsigned short       | индекс строки                 |
| k              | unsigned short       | индекс элемента строки        |
| triangle       | unsigned long long** | треугольник Паскаля           |

### Код программы
```c
#include <stdio.h>
#include <stdlib.h>

// Функция вычисления факториала
unsigned long long factorial(const unsigned long long n) {
    if (n == 0) {
        return 1;
    }
    unsigned long long result = 1;
    for (unsigned long long i = 1; i <= n; i++) {
        result *= i;
    }
    return result;
}

// Функция вычисления биноминального коэффициента
unsigned long long C(const unsigned short n, const unsigned short k) {
    return factorial(n) / (factorial(k) * factorial(n - k));
}

// Печать пробелов для красивого треугольника
void PreSpaces(const unsigned short count) {
    for (unsigned short i = 0; i < count; i++) {
        printf(" ");
    }
}

int main() {
    printf("Enter count of strings of the Pascal triangle:");
    unsigned short N = 0; // от 0 до 65535
    scanf("%hd", &N);
    printf("Pascal triangle:\n");

    // Динамически выделяем память под массив, в котором будем хранить треугольник Паскаля
    unsigned long long** triangle = (unsigned long long**) malloc(N * sizeof(unsigned long long*));
    for (unsigned short i = 0; i < N; i++) {
        triangle[i] = (unsigned long long*) malloc((i + 1) * sizeof(unsigned long long));

        // Используем бином Ньютона, чтобы построить треугольник Паскаля
        for (unsigned short k = 0; k <= i; k++) {
            triangle[i][k] = C(i, k);
        }
    }

    // Печатаем треугольник
    for (unsigned short i = 0; i < N; i++) {
        PreSpaces(N - i);
        for (unsigned short k = 0; k <= i; k++) {
            printf("%llu ", triangle[i][k]);
        }
        printf("\n");
    }

    // Освобождаем память
    for (unsigned short i = 0; i < N; i++) {
        free(triangle[i]);
    }
    free(triangle);

    return 0;
}
```
### Результат работы программы
![img_2.png](img_2.png)

## Задание №10. Сортированный связный список

### Постановка задачи
Реализуйте программу, которая читает последовательность чисел и сохраняет их в отсортированном порядке с использованием связного списка.
- **Вход.** Имя текстового файла с исходными данными передается через командную строку. Файл содержит
целые числа, по одному в строке, в произвольном порядке.
- **Выход.** Те же числа, выведенные в возрастающем порядке, по одному в строке (от меньшего к большему
значению).
- **Требования.** Для хранения чисел использовать односвязный список: каждый считанный элемент вставлять в список сразу в нужную позицию, поддерживая сортированный порядок списка на этапе вставки
(не сортировать весь список заново после заполнения, а именно вставлять в правильное место). Не использовать массивы для хранения всех элементов сразу – добавление элементов происходит по одному с
динамическим выделением памяти под каждый новый узел списка. После считывания всех чисел и вывода
результата очистить память, выделенную под узлы связного списка. Алгоритм должен эффективно обрабатывать большие входные файлы (по памяти ограничен только размерами доступной памяти, по времени
– вставка каждого элемента должна выполняться за время, пропорциональное длине списка).


### Список идентификаторов

### Код программы
```c

```
### Результат работы программы






## Задание №9. Умножение матриц произвольного размера

### Постановка задачи

Напишите программу для перемножения двух матриц.
- **Вход.** Два имени файлов передаются программе в аргументах командной строки. Первый файл содержит
первую матрицу, второй – вторую матрицу. Формат каждой матрицы в файле: первая строка – два целых
числа R и C (число строк и столбцов матрицы), далее R строк, каждая из которых содержит C чисел (элементы матрицы, через пробел).
- **Выход.** Если матрицы можно перемножить (число столбцов первой равно числу строк второй), вывести
результирующую матрицу в стандартный вывод (каждая строка результата – в новой строке, элементы
через пробел). Если размеры матриц несовместимы для умножения – вывести сообщение об ошибке.
- **Требования.** Матрицы произвольного размера, ограниченные лишь доступной памятью. Память под матрицы должна выделяться динамически (двумерные массивы создавать через malloc/calloc: например,
выделить массив указателей на строки, а затем для каждого указателя – массив элементов строки). Не использовать статические двумерные массивы фиксированного размера. При попытке перемножить несовместимые матрицы программа должна не выполнять никаких вычислений и выдать понятное сообщение
об ошибке. Результат умножения сохранить в новой динамически выделенной матрице. После завершения вычислений освободить всю выделенную память (включая память под обе входные матрицы и под
результат).

### Список идентификаторов

### Код программы
```c

```
### Результат работы программы









## Информация о студенте
Тоц Леонид Александрович, 1 курс, ИВТ-2